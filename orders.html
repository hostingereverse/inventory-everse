<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orders - Everse Inventory Management</title>
  
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
  <div id="navbar"></div>
  
  <div class="container-fluid mt-4">
    <h1 class="mb-4">Order Management</h1>
    
    <!-- Filter Bar -->
    <div class="filter-bar">
      <div class="row g-3">
        <div class="col-md-3">
          <input type="text" class="form-control" id="searchOrderID" placeholder="Search Order ID...">
        </div>
        <div class="col-md-2">
          <input type="date" class="form-control" id="filterDate" placeholder="Filter by Date">
        </div>
        <div class="col-md-2">
          <select class="form-select" id="filterStatus">
            <option value="">All Status</option>
            <option value="PROCESSING">Processing</option>
            <option value="SHIPPED">Shipped</option>
            <option value="DELIVERED">Delivered</option>
            <option value="CANCELED">Canceled</option>
          </select>
        </div>
        <div class="col-md-2">
          <select class="form-select" id="filterLocation">
            <option value="">All Locations</option>
          </select>
        </div>
        <div class="col-md-2">
          <input type="text" class="form-control" id="filterSalesPerson" placeholder="Sales Person...">
        </div>
        <div class="col-md-2">
          <input type="text" class="form-control" id="filterProduct" placeholder="Filter by Product...">
        </div>
        <div class="col-md-1">
          <button class="btn btn-primary w-100" onclick="applyFilters()">Filter</button>
        </div>
      </div>
      <div class="row g-3 mt-2">
        <div class="col-md-3">
          <label class="form-label">Upload Orders CSV</label>
          <input type="file" class="form-control" id="csvUpload" accept=".csv" onchange="handleCSVUpload(event)">
          <small class="text-muted">Upload CSV file with new orders. Existing order IDs will be ignored.</small>
        </div>
      </div>
    </div>
    
    <!-- New Order Form -->
    <div class="card mb-4">
      <div class="card-header">
        <h4 class="mb-0">New Order</h4>
      </div>
      <div class="card-body">
        <form id="newOrderForm">
          <div class="row g-3">
            <div class="col-md-2">
              <input type="text" class="form-control" id="newOrderID" placeholder="Order ID" required>
            </div>
            <div class="col-md-2">
              <input type="date" class="form-control" id="newOrderDate" required>
            </div>
            <div class="col-md-2">
              <select class="form-select" id="newOrderLocation" required>
                <option value="">Select Location</option>
              </select>
            </div>
            <div class="col-md-2">
              <select class="form-select" id="newOrderProduct" required>
                <option value="">Select Product</option>
              </select>
            </div>
            <div class="col-md-1">
              <input type="number" class="form-control" id="newOrderSP" placeholder="SP" required>
            </div>
            <div class="col-md-1">
              <input type="number" class="form-control" id="newOrderCP" placeholder="CP">
            </div>
            <div class="col-md-1">
              <input type="number" class="form-control" id="newOrderGST" placeholder="GST">
            </div>
            <div class="col-md-1">
              <button type="submit" class="btn btn-primary w-100">Add</button>
            </div>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Orders Table -->
    <div class="card">
      <div class="card-header d-flex justify-content-between align-items-center">
        <h4 class="mb-0">All Orders</h4>
        <div>
          <button class="btn btn-sm btn-success me-2" onclick="document.getElementById('csvUpload').click()">
            ðŸ“¤ Upload CSV
          </button>
          <button class="btn btn-sm btn-light" onclick="exportOrders()">Export CSV</button>
        </div>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table">
            <thead>
              <tr>
                <th>Order ID</th>
                <th>Date</th>
                <th>Location</th>
                <th>Product</th>
                <th>Status</th>
                <th>SP</th>
                <th>CP</th>
                <th>GST</th>
                <th>Sales Person</th>
                <th>Remarks</th>
                <th>Tracking</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="ordersTable">
              <tr>
                <td colspan="12" class="text-center">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Google API -->
  <script src="https://apis.google.com/js/api.js"></script>
  <!-- PapaParse -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- Config -->
  <script src="config.js"></script>
  <!-- Authentication (Legacy - fallback) -->
  <script src="auth-config.js"></script>
  <script src="auth.js"></script>
  <!-- Google Auth (New System) -->
  <script src="js/google-auth.js"></script>
  <!-- Audit Trail -->
  <script src="js/audit-trail.js"></script>
  <!-- Data Persistence -->
  <script src="js/data-persistence.js"></script>
  <!-- Data Loader -->
  <script src="js/data-loader.js"></script>
  <!-- API Helper -->
  <script src="js/api.js"></script>
  <!-- App Utils -->
  <script src="js/app.js"></script>
  <script src="js/auto-product.js"></script>
  <script src="js/tracking.js"></script>
  <!-- App Initialization -->
  <script src="js/init.js"></script>
  
  <script>
    let allOrders = [];
    let filteredOrders = [];
    
    async function loadOrders() {
      try {
        // Wait for app initialization
        if (typeof AppInit !== 'undefined') {
          await AppInit.init();
        }
        
        // Use DataLoader if available, otherwise fallback
        let data;
        if (typeof DataLoader !== 'undefined' && DataLoader.loadAllData) {
          data = await DataLoader.loadAllData();
        } else {
          data = await initApp();
        }
        
        allOrders = data.orders || [];
        
        // Sort orders: unfulfilled first, then new to old
        allOrders.sort((a, b) => {
          // First sort by unfulfilled status (PROCESSING, SHIPPED first)
          const aStatus = (a.status || '').toUpperCase();
          const bStatus = (b.status || '').toUpperCase();
          const aUnfulfilled = aStatus === 'PROCESSING' || aStatus === 'SHIPPED';
          const bUnfulfilled = bStatus === 'PROCESSING' || bStatus === 'SHIPPED';
          
          if (aUnfulfilled && !bUnfulfilled) return -1;
          if (!aUnfulfilled && bUnfulfilled) return 1;
          
          // Then sort by date (newest first)
          const aDate = parseDate(a.date || '');
          const bDate = parseDate(b.date || '');
          if (aDate && bDate) {
            return bDate - aDate; // Newer first
          }
          if (aDate) return -1;
          if (bDate) return 1;
          
          return 0;
        });
        
        filteredOrders = [...allOrders];
        
        // Populate location dropdowns
        populateLocations();
        populateProducts(data.inventory);
        
        // Set default date
        document.getElementById('newOrderDate').value = new Date().toISOString().split('T')[0];
        
        renderOrders();
      } catch (error) {
        console.error('Load orders error:', error);
        showToast('Error loading orders', 'danger');
      }
    }
    
    // Helper function to parse dates
    function parseDate(dateStr) {
      if (!dateStr) return null;
      // Try different date formats
      try {
        // ISO format
        const isoDate = new Date(dateStr);
        if (!isNaN(isoDate.getTime())) return isoDate;
        
        // DD-MM or DD-MM-YY format
        const parts = dateStr.split('-');
        if (parts.length >= 2) {
          const day = parseInt(parts[0]);
          const month = parseInt(parts[1]) - 1;
          const year = parts.length > 2 ? parseInt('20' + parts[2]) : new Date().getFullYear();
          const date = new Date(year, month, day);
          if (!isNaN(date.getTime())) return date;
        }
      } catch (e) {
        console.warn('Date parse error:', e);
      }
      return null;
    }
    
    function populateLocations() {
      const selects = ['filterLocation', 'newOrderLocation'];
      selects.forEach(id => {
        const select = document.getElementById(id);
        if (!select) return;
        select.innerHTML = '<option value="">All Locations</option>';
        CONFIG.WAREHOUSES.forEach(wh => {
          const option = document.createElement('option');
          option.value = wh;
          option.textContent = wh;
          select.appendChild(option);
        });
      });
    }
    
    function populateProducts(inventory) {
      const select = document.getElementById('newOrderProduct');
      if (!select) return;
      select.innerHTML = '<option value="">Select Product</option>';
      (inventory || []).forEach(product => {
        const option = document.createElement('option');
        option.value = product.name;
        option.textContent = product.name;
        select.appendChild(option);
      });
    }
    
    // Helper function to parse dates
    function parseDate(dateStr) {
      if (!dateStr) return null;
      try {
        // ISO format
        const isoDate = new Date(dateStr);
        if (!isNaN(isoDate.getTime())) return isoDate;
        
        // DD-MM or DD-MM-YY format
        const parts = dateStr.split('-');
        if (parts.length >= 2) {
          const day = parseInt(parts[0]);
          const month = parseInt(parts[1]) - 1;
          const year = parts.length > 2 ? parseInt('20' + parts[2]) : new Date().getFullYear();
          const date = new Date(year, month, day);
          if (!isNaN(date.getTime())) return date;
        }
      } catch (e) {
        console.warn('Date parse error:', e);
      }
      return null;
    }
    
    function applyFilters() {
      const orderID = document.getElementById('searchOrderID').value.toLowerCase();
      const date = document.getElementById('filterDate').value;
      const status = document.getElementById('filterStatus').value;
      const location = document.getElementById('filterLocation').value;
      const salesPerson = document.getElementById('filterSalesPerson').value.toLowerCase();
      const product = (document.getElementById('filterProduct') || {}).value?.toLowerCase() || '';
      
      filteredOrders = allOrders.filter(order => {
        const orderIDMatch = !orderID || (order.orderid || '').toLowerCase().includes(orderID);
        const dateMatch = !date || (order.date || '').includes(date);
        const statusMatch = !status || (order.status || '').toUpperCase() === status.toUpperCase();
        const locationMatch = !location || 
          (order.deliverylocation || order.deliveryLocation || '').toUpperCase().includes(location.toUpperCase());
        const salesPersonMatch = !salesPerson || 
          (order.salesperson || '').toLowerCase().includes(salesPerson);
        const productMatch = !product || 
          (order.product || '').toLowerCase().includes(product);
        
        return orderIDMatch && dateMatch && statusMatch && locationMatch && salesPersonMatch && productMatch;
      });
      
      // Maintain sort order (unfulfilled first, then new to old)
      filteredOrders.sort((a, b) => {
        const aStatus = (a.status || '').toUpperCase();
        const bStatus = (b.status || '').toUpperCase();
        const aUnfulfilled = aStatus === 'PROCESSING' || aStatus === 'SHIPPED';
        const bUnfulfilled = bStatus === 'PROCESSING' || bStatus === 'SHIPPED';
        
        if (aUnfulfilled && !bUnfulfilled) return -1;
        if (!aUnfulfilled && bUnfulfilled) return 1;
        
        const aDate = parseDate(a.date || '');
        const bDate = parseDate(b.date || '');
        if (aDate && bDate) return bDate - aDate;
        if (aDate) return -1;
        if (bDate) return 1;
        return 0;
      });
      
      renderOrders();
    }
    
    function renderOrders() {
      const tbody = document.getElementById('ordersTable');
      if (!tbody) return;
      
        if (filteredOrders.length === 0) {
        tbody.innerHTML = '<tr><td colspan="12" class="text-center">No orders found</td></tr>';
        return;
      }
      
      tbody.innerHTML = filteredOrders.map(order => {
        const status = (order.status || '').toUpperCase();
        let statusClass = 'status-processing';
        if (status === 'SHIPPED') statusClass = 'bg-info text-white';
        else if (status === 'DELIVERED' || status === 'FULFILLED') statusClass = 'status-fulfilled';
        else if (status === 'CANCELED') statusClass = 'status-canceled';
        return `
          <tr>
            <td>${order.orderid || ''}</td>
            <td>${order.date || ''}</td>
            <td>${order.deliverylocation || order.deliveryLocation || ''}</td>
            <td>${order.product || ''}</td>
            <td><span class="badge ${statusClass}">${status}</span></td>
            <td>${formatCurrency(order.sp || 0)}</td>
            <td>${formatCurrency(order.cp || 0)}</td>
            <td>${formatCurrency(order.gst || 0)}</td>
            <td>${order.salesperson || ''}</td>
            <td>${order.remarks || ''}</td>
            <td>
              ${(() => {
                const tracking = typeof Tracking !== 'undefined' ? Tracking.getTrackingInfo(order.orderid || '') : null;
                if (tracking) {
                  return `<span class="badge ${tracking.isFulfilled ? 'bg-success' : 'bg-info'}">${tracking.status}</span><br><small>${tracking.trackingNumber}</small>`;
                } else if (status === 'SHIPPED' || status === 'PROCESSING') {
                  return `<button class="btn btn-sm btn-secondary" onclick="addTracking('${order.orderid || ''}')">Add Tracking</button>`;
                }
                return '-';
              })()}
            </td>
            <td>
              ${status === 'PROCESSING' ? 
                `<button class="btn btn-sm btn-info" onclick="shipOrder('${order.orderid || ''}')">Ship</button>
                 <button class="btn btn-sm btn-success" onclick="deliverOrder('${order.orderid || ''}')">Deliver</button>` : 
                status === 'SHIPPED' ?
                `<button class="btn btn-sm btn-success" onclick="deliverOrder('${order.orderid || ''}')">Deliver</button>` :
                ''}
            </td>
          </tr>
        `;
      }).join('');
    }
    
    function addTracking(orderID) {
      const trackingNum = prompt('Enter tracking number:');
      if (!trackingNum) return;
      
      const courierId = prompt('Enter courier ID (delhivery/shreetirupati):', 'delhivery');
      if (!courierId) return;
      
      if (typeof Tracking !== 'undefined') {
        Tracking.trackOrder(orderID, trackingNum.trim(), courierId).then(result => {
          if (result.success) {
            showToast('Tracking added successfully', 'success');
            renderOrders();
          } else {
            showToast('Failed to add tracking: ' + result.error, 'danger');
          }
        });
      } else {
        showToast('Tracking system not loaded', 'danger');
      }
    }
    
    async function shipOrder(orderID) {
      if (!confirm('Mark this order as Shipped? Add tracking number if available.')) return;
      
      const trackingNum = prompt('Enter tracking number (optional, press Cancel to skip):');
      if (trackingNum && typeof Tracking !== 'undefined') {
        const courierId = prompt('Enter courier ID:', 'delhivery') || 'delhivery';
        await Tracking.trackOrder(orderID, trackingNum.trim(), courierId);
      }
      
      const order = allOrders.find(o => o.orderid === orderID);
      const oldStatus = order ? order.status : '';
      
      await updateOrderStatus(orderID, 'SHIPPED');
      
      // Log audit event
      if (typeof logAuditEvent === 'function') {
        await logAuditEvent({
          action: 'UPDATE',
          entity: 'Order',
          entityID: orderID,
          oldValue: { status: oldStatus },
          newValue: { status: 'SHIPPED' },
          details: `Order ${orderID} status changed from ${oldStatus} to SHIPPED`
        });
      }
      
      showToast('Order marked as Shipped', 'success');
      await loadOrders();
    }
    
    async function deliverOrder(orderID) {
      const order = allOrders.find(o => o.orderid === orderID);
      const oldStatus = order ? order.status : '';
      
      await updateOrderStatus(orderID, 'DELIVERED');
      
      // Log audit event
      if (typeof logAuditEvent === 'function') {
        await logAuditEvent({
          action: 'UPDATE',
          entity: 'Order',
          entityID: orderID,
          oldValue: { status: oldStatus },
          newValue: { status: 'DELIVERED' },
          details: `Order ${orderID} status changed from ${oldStatus} to DELIVERED`
        });
      }
      
      showToast('Order marked as Delivered', 'success');
      await loadOrders();
    }
    
    async function fulfillOrder(orderID) {
      try {
        const order = allOrders.find(o => o.orderid === orderID);
        if (!order) {
          showToast('Order not found', 'danger');
          return;
        }
        
        const location = order.deliverylocation || order.deliveryLocation || '';
        const warehouse = CONFIG.WAREHOUSES.find(w => 
          location.toUpperCase().includes(w.toUpperCase().substring(0, 3))
        ) || location;
        
        const product = appData.inventory.find(p => 
          p.name === order.product || p.productID === order.product
        );
        
        if (!product) {
          showToast('Product not found', 'danger');
          return;
        }
        
        const qty = 1; // Assuming qty is 1 if not specified
        const stock = product.stock[warehouse] || 0;
        
        if (stock >= qty) {
          // Deduct stock
          await logMovement({
            warehouse: warehouse,
            productID: product.productID,
            type: 'Out',
            qty: qty,
            notes: `Order fulfillment: ${orderID}`,
            user: 'System'
          });
          
          // Update order status
          const oldStatus = order.status;
          await updateOrderStatus(orderID, 'DELIVERED');
          
          // Log audit event
          if (typeof logAuditEvent === 'function') {
            await logAuditEvent({
              action: 'FULFILL',
              entity: 'Order',
              entityID: orderID,
              oldValue: { status: oldStatus },
              newValue: { status: 'DELIVERED' },
              details: `Order ${orderID} fulfilled and delivered - stock deducted from ${warehouse}`
            });
          }
          
          showToast(`Order ${orderID} delivered successfully`, 'success');
          
          // Reload data
          await loadOrders();
        } else {
          // Add to gaps
          await handleGap(order, appData.inventory);
          showToast(`Insufficient stock. Added to gaps.`, 'warning');
        }
      } catch (error) {
        console.error('Fulfill order error:', error);
        showToast('Error fulfilling order', 'danger');
      }
    }
    
    async function updateOrderStatus(orderID, status) {
      try {
        const ordersRes = await loadSheet(CONFIG.SHEETS.ORDERS.range, CONFIG.SHEETS.ORDERS.sheetKey);
        const rows = ordersRes.values || [];
        const orderIndex = rows.findIndex(r => r[0] === orderID);
        
        if (orderIndex >= 0) {
          rows[orderIndex][4] = status; // Status column
          await updateSheet(CONFIG.SHEETS.ORDERS.range, rows, CONFIG.SHEETS.ORDERS.sheetKey);
          
          // Update local data
          const order = allOrders.find(o => o.orderid === orderID);
          if (order) {
            order.status = status;
          }
        }
      } catch (error) {
        console.error('Update order status error:', error);
        throw error;
      }
    }
    
    window.addTracking = addTracking;
    window.shipOrder = shipOrder;
    window.deliverOrder = deliverOrder;
    
    // CSV Upload Handler
    async function handleCSVUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      if (!file.name.toLowerCase().endsWith('.csv')) {
        showToast('Please upload a CSV file', 'danger');
        return;
      }
      
      try {
        showToast('Processing CSV file...', 'info');
        
        const text = await file.text();
        const parsed = Papa.parse(text, {
          header: true,
          skipEmptyLines: true
        });
        
        if (!parsed.data || parsed.data.length === 0) {
          showToast('CSV file is empty or invalid', 'danger');
          return;
        }
        
        // Load existing orders to check for duplicates
        const data = await initApp();
        const existingOrderIDs = new Set((data.orders || []).map(o => (o.orderid || '').toString().trim()));
        
        // Parse CSV rows - try to match common column names
        const newOrders = [];
        const skippedOrders = [];
        
        parsed.data.forEach((row, idx) => {
          // Try different column name variations
          const orderID = (row.OrderID || row['Order ID'] || row.orderid || row.OrderId || row[0] || '').toString().trim();
          
          if (!orderID) {
            skippedOrders.push({ row: idx + 1, reason: 'Missing Order ID' });
            return;
          }
          
          // Check if order already exists
          if (existingOrderIDs.has(orderID)) {
            skippedOrders.push({ orderID, reason: 'Order ID already exists' });
            return;
          }
          
          // Parse order data
          const orderDate = row.Date || row.date || row[1] || new Date().toISOString().split('T')[0];
          const location = row.DeliveryLocation || row.Location || row['Delivery Location'] || row.deliverylocation || row[2] || '';
          const product = row.Product || row.product || row[3] || '';
          const status = (row.Status || row.status || row[4] || 'PROCESSING').toUpperCase();
          const sp = parseFloat(row.SP || row.sp || row.SalePrice || row[5] || 0) || 0;
          const cp = parseFloat(row.CP || row.cp || row.CostPrice || row[6] || 0) || 0;
          const gst = parseFloat(row.GST || row.gst || row[7] || 0) || 0;
          const salesPerson = row.SalesPerson || row['Sales Person'] || row.salesperson || row[8] || '';
          const remarks = row.Remarks || row.remarks || row[9] || '';
          
          newOrders.push({
            orderid: orderID,
            date: orderDate,
            deliverylocation: location,
            product: product,
            status: status,
            sp: sp,
            cp: cp,
            gst: gst,
            salesperson: salesPerson,
            remarks: remarks
          });
        });
        
        // Save new orders to Google Sheets
        if (newOrders.length > 0) {
          const ordersRes = await loadSheet(CONFIG.SHEETS.ORDERS.range, CONFIG.SHEETS.ORDERS.sheetKey);
          const rows = ordersRes.values || [];
          
          // Get header row if exists
          let headerRow = rows.length > 0 && rows[0] ? rows[0] : CONFIG.SHEETS.ORDERS.cols;
          
          // Add new orders
          newOrders.forEach(order => {
            const newRow = [
              order.orderid,
              order.date,
              order.deliverylocation,
              order.product,
              order.status,
              order.sp || '',
              order.cp || '',
              order.gst || '',
              order.salesperson || '',
              order.remarks || ''
            ];
            rows.push(newRow);
          });
          
          await updateSheet(CONFIG.SHEETS.ORDERS.range, rows, CONFIG.SHEETS.ORDERS.sheetKey);
          
          showToast(`âœ… ${newOrders.length} new orders added. ${skippedOrders.length} skipped (duplicates or invalid).`, 'success');
          
          // Show skipped orders summary if any
          if (skippedOrders.length > 0) {
            console.log('Skipped orders:', skippedOrders);
          }
          
          // Reload orders
          await loadOrders();
        } else {
          showToast(`No new orders to add. ${skippedOrders.length} skipped (duplicates or invalid).`, 'warning');
        }
        
        // Reset file input
        event.target.value = '';
        
      } catch (error) {
        console.error('CSV upload error:', error);
        showToast('Error processing CSV file: ' + error.message, 'danger');
      }
    }
    
    window.handleCSVUpload = handleCSVUpload;
    
    async function exportOrders() {
      exportToCSV(filteredOrders, `orders_${new Date().toISOString().split('T')[0]}.csv`);
      showToast('Orders exported to CSV', 'success');
    }
    
    // New order form submission
    document.getElementById('newOrderForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const newOrder = {
        orderid: document.getElementById('newOrderID').value,
        date: formatDate(document.getElementById('newOrderDate').value),
        deliverylocation: document.getElementById('newOrderLocation').value,
        product: document.getElementById('newOrderProduct').value,
        status: 'PROCESSING',
        sp: parseFloat(document.getElementById('newOrderSP').value) || 0,
        cp: parseFloat(document.getElementById('newOrderCP').value) || 0,
        gst: parseFloat(document.getElementById('newOrderGST').value) || 0,
        salesperson: '',
        remarks: ''
      };
      
      try {
        const values = [
          newOrder.orderid,
          newOrder.date,
          newOrder.deliverylocation,
          newOrder.product,
          newOrder.status,
          newOrder.sp,
          newOrder.cp,
          newOrder.gst,
          newOrder.salesperson,
          newOrder.remarks
        ];
        
        await saveSheet(CONFIG.SHEETS.ORDERS.range, values, CONFIG.SHEETS.ORDERS.sheetKey);
        showToast('Order added successfully', 'success');
        
        // Reset form
        document.getElementById('newOrderForm').reset();
        document.getElementById('newOrderDate').value = new Date().toISOString().split('T')[0];
        
        // Reload orders
        await loadOrders();
      } catch (error) {
        console.error('Add order error:', error);
        showToast('Error adding order', 'danger');
      }
    });
    
    // Initialize
    document.addEventListener('DOMContentLoaded', loadOrders);
    
    // Search on input
    document.getElementById('searchOrderID')?.addEventListener('input', applyFilters);
  </script>
</body>
</html>

