<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stock Management - Everse Inventory Management</title>
  
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
  <div id="navbar"></div>
  
  <div class="container-fluid mt-4">
    <h1 class="mb-4">Stock Management</h1>
    
    <!-- Serial Number Mapping (First Time Entry) -->
    <div class="card mb-4">
      <div class="card-header">
        <h4 class="mb-0">Serial Number Mapping (First Time Entry)</h4>
      </div>
      <div class="card-body">
        <form id="serialMappingForm">
          <div class="row g-3">
            <div class="col-md-3">
              <label class="form-label">Scan Serial Number (Barcode)</label>
              <input type="text" class="form-control" id="serialNumberInput" placeholder="Scan or enter serial number" required autofocus>
              <small class="text-muted">Use barcode scanner or type serial number</small>
            </div>
            <div class="col-md-3">
              <label class="form-label">Warehouse</label>
              <select class="form-select" id="serialWarehouse" required>
                <option value="">Select Warehouse</option>
              </select>
            </div>
            <div class="col-md-4">
              <label class="form-label">Search Product</label>
              <div class="input-group">
                <input type="text" class="form-control" id="productSearch" placeholder="Search product by name or ID..." autocomplete="off">
                <button type="button" class="btn btn-outline-info" onclick="searchProductOnEverse()" title="Search on everse.in">
                  üîç everse.in
                </button>
              </div>
              <select class="form-select mt-2" id="serialProduct" required style="display: none;">
                <option value="">Select Product</option>
              </select>
              <div id="productSearchResults" class="list-group mt-2" style="max-height: 200px; overflow-y: auto; display: none;"></div>
            </div>
            <div class="col-md-2 d-flex align-items-end">
              <button type="submit" class="btn btn-success w-100">Map Serial</button>
            </div>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Stock Movement Entry (Using Serial Numbers) -->
    <div class="card mb-4">
      <div class="card-header">
        <h4 class="mb-0">Stock Movement Entry (Using Serial Numbers)</h4>
      </div>
      <div class="card-body">
        <form id="stockForm">
          <div class="row g-3">
            <div class="col-md-12">
              <label class="form-label">Scan Serial Number(s)</label>
              <textarea class="form-control" id="serialNumbersInput" rows="3" placeholder="Scan serial numbers (one per line or comma-separated)" required></textarea>
              <small class="text-muted">Scan multiple serial numbers using barcode scanner (separated by Enter) or comma-separated</small>
            </div>
            <div class="col-md-3">
              <label class="form-label">Type</label>
              <select class="form-select" id="stockType" required>
                <option value="In">In</option>
                <option value="Out">Out</option>
              </select>
            </div>
            <div class="col-md-3">
              <label class="form-label">Quantity (Auto-filled from serials)</label>
              <input type="number" class="form-control" id="stockQty" min="1" readonly>
            </div>
            <div class="col-md-6">
              <label class="form-label">Notes</label>
              <input type="text" class="form-control" id="stockNotes" placeholder="Optional notes...">
            </div>
            <div class="col-md-12">
              <div id="serialPreview" class="alert alert-info" style="display: none;"></div>
            </div>
            <div class="col-md-12">
              <button type="submit" class="btn btn-primary">Record Movement</button>
            </div>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Combo Breakdown -->
    <div class="card mb-4">
      <div class="card-header">
        <h4 class="mb-0">Break Down Combo Product</h4>
      </div>
      <div class="card-body">
        <form id="comboBreakdownForm">
          <div class="row g-3">
            <div class="col-md-3">
              <label class="form-label">Combo Serial Number</label>
              <input type="text" class="form-control" id="comboSerial" placeholder="Scan combo serial number" required>
            </div>
            <div class="col-md-3">
              <label class="form-label">Reference Number</label>
              <input type="text" class="form-control" id="breakdownRef" placeholder="Auto-generated" readonly>
            </div>
            <div class="col-md-12">
              <label class="form-label">Individual Products</label>
              <div id="individualProductsList">
                <div class="row g-2 mb-2">
                  <div class="col-md-4">
                    <input type="text" class="form-control" placeholder="Product ID or Name" required>
                  </div>
                  <div class="col-md-2">
                    <input type="number" class="form-control" placeholder="Qty" min="1" required>
                  </div>
                  <div class="col-md-5">
                    <input type="text" class="form-control" placeholder="Serial Numbers (comma-separated)" required>
                  </div>
                  <div class="col-md-1">
                    <button type="button" class="btn btn-danger" onclick="removeProductRow(this)">-</button>
                  </div>
                </div>
              </div>
              <button type="button" class="btn btn-sm btn-secondary" onclick="addProductRow()">+ Add Product</button>
            </div>
            <div class="col-md-12">
              <button type="submit" class="btn btn-warning">Break Down Combo</button>
            </div>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Stock History Filters -->
    <div class="filter-bar mb-4">
      <div class="row g-3">
        <div class="col-md-2">
          <label class="form-label">Date From</label>
          <input type="date" class="form-control" id="filterMovementDate" placeholder="Filter by Date">
        </div>
        <div class="col-md-2">
          <label class="form-label">Date To</label>
          <input type="date" class="form-control" id="filterDateTo" placeholder="To Date">
        </div>
        <div class="col-md-2">
          <label class="form-label">Warehouse</label>
          <select class="form-select" id="filterMovementWarehouse">
            <option value="">All Warehouses</option>
          </select>
        </div>
        <div class="col-md-2">
          <label class="form-label">Type</label>
          <select class="form-select" id="filterMovementType">
            <option value="">All Types</option>
            <option value="In">In</option>
            <option value="Out">Out</option>
          </select>
        </div>
        <div class="col-md-2 d-flex align-items-end">
          <button class="btn btn-primary me-2" onclick="applyMovementFilters()">Filter</button>
          <button class="btn btn-secondary" onclick="resetMovementFilters()">Reset</button>
        </div>
      </div>
    </div>
    
    <!-- Stock Movements Table -->
    <div class="card">
      <div class="card-header d-flex justify-content-between align-items-center">
        <h4 class="mb-0">Stock Movement History</h4>
        <div>
          <span id="movementPageInfo" class="me-3"></span>
          <button class="btn btn-sm btn-light" onclick="exportMovements()">Export CSV</button>
        </div>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Warehouse</th>
                <th>Product ID</th>
                <th>Type</th>
                <th>Quantity</th>
                <th>Serial Numbers</th>
                <th>Notes</th>
                <th>User</th>
              </tr>
            </thead>
            <tbody id="movementsTable">
              <tr>
                <td colspan="7" class="text-center">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
        
        <!-- Pagination -->
        <nav aria-label="Movements pagination">
          <ul class="pagination justify-content-center" id="movementPagination">
          </ul>
        </nav>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Google API -->
  <script src="https://apis.google.com/js/api.js"></script>
  <!-- PapaParse -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- Config -->
  <script src="config.js"></script>
  <!-- Authentication (Legacy - fallback) -->
  <script src="auth-config.js"></script>
  <script src="auth.js"></script>
  <!-- Google Auth (New System) -->
  <script src="js/google-auth.js"></script>
  <!-- Audit Trail -->
  <script src="js/audit-trail.js"></script>
  <!-- Data Persistence -->
  <script src="js/data-persistence.js"></script>
  <!-- Data Loader -->
  <script src="js/data-loader.js"></script>
  <!-- API Helper -->
  <script src="js/api.js"></script>
  <!-- App Utils -->
  <script src="js/app.js"></script>
  <script src="js/auto-product.js"></script>
  <script src="js/serial-tracker.js"></script>
  <script src="js/product-scraper.js"></script>
  <!-- App Initialization -->
  <script src="js/init.js"></script>
  
  <script>
    let allMovements = [];
    let filteredMovements = [];
    let currentPage = 1;
    const itemsPerPage = 10;
    
    async function loadStock() {
      try {
        // Wait for app initialization
        if (typeof AppInit !== 'undefined') {
          await AppInit.init();
        }
        
        // Use DataLoader if available, otherwise fallback
        let data;
        if (typeof DataLoader !== 'undefined' && DataLoader.loadAllData) {
          data = await DataLoader.loadAllData();
        } else {
          data = await initApp();
        }
        
        allMovements = data.movements || [];
        
        // Set default date filter to past 7 days
        const today = new Date();
        const sevenDaysAgo = new Date(today);
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        
        // Format dates for input field
        const dateFromStr = sevenDaysAgo.toISOString().split('T')[0];
        const dateToStr = today.toISOString().split('T')[0];
        
        // Set default date filter
        document.getElementById('filterMovementDate').value = dateFromStr;
        document.getElementById('filterDateTo')?.remove(); // Remove if exists
        
        // Add date-to input if it doesn't exist
        let dateToInput = document.getElementById('filterDateTo');
        if (!dateToInput) {
          const dateFromInput = document.getElementById('filterMovementDate');
          const parent = dateFromInput.parentElement;
          const newInput = document.createElement('div');
          newInput.className = 'col-md-2';
          newInput.innerHTML = `
            <label class="form-label">Date To</label>
            <input type="date" class="form-control" id="filterDateTo" value="${dateToStr}">
          `;
          parent.parentElement.insertBefore(newInput, parent.nextSibling);
        } else {
          dateToInput.value = dateToStr;
        }
        
        // Filter by default 7 days
        filteredMovements = allMovements.filter(movement => {
          const movementDate = movement.date || '';
          return movementDate >= dateFromStr && movementDate <= dateToStr;
        });
        
        // Sort by date descending
        filteredMovements.sort((a, b) => {
          const dateA = new Date(a.date || '1970-01-01');
          const dateB = new Date(b.date || '1970-01-01');
          return dateB - dateA;
        });
        
        populateWarehouses();
        populateProducts(data.inventory);
        setupProductSearch();
        setupSerialNumberInput();
        setupSerialNumbersInput();
        renderMovements();
        
        // Focus serial input for barcode scanner
        document.getElementById('serialNumberInput')?.focus();
      } catch (error) {
        console.error('Load stock error:', error);
        showToast('Error loading stock movements', 'danger');
      }
    }
    
    let allProducts = [];
    
    function populateWarehouses() {
      const selects = ['serialWarehouse', 'filterMovementWarehouse'];
      selects.forEach(id => {
        const select = document.getElementById(id);
        if (!select) return;
        select.innerHTML = id === 'serialWarehouse' ? '<option value="">Select Warehouse</option>' : '<option value="">All Warehouses</option>';
        CONFIG.WAREHOUSES.forEach(wh => {
          const option = document.createElement('option');
          option.value = wh;
          option.textContent = wh;
          select.appendChild(option);
        });
      });
    }
    
    function populateProducts(inventory) {
      allProducts = inventory || [];
      // Product search will be handled by search functionality
    }
    
    // Product search functionality
    function setupProductSearch() {
      const searchInput = document.getElementById('productSearch');
      const resultsDiv = document.getElementById('productSearchResults');
      const productSelect = document.getElementById('serialProduct');
      let selectedProduct = null;
      
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase().trim();
        
        if (query.length < 2) {
          resultsDiv.style.display = 'none';
          productSelect.style.display = 'none';
          return;
        }
        
        // Filter products
        const matches = allProducts.filter(p => 
          (p.name || '').toLowerCase().includes(query) ||
          (p.productID || '').toLowerCase().includes(query) ||
          (p.description || '').toLowerCase().includes(query)
        ).slice(0, 10);
        
        if (matches.length === 0) {
          resultsDiv.innerHTML = '<div class="list-group-item">No products found</div>';
          resultsDiv.style.display = 'block';
          return;
        }
        
        resultsDiv.innerHTML = matches.map(p => `
          <a href="#" class="list-group-item list-group-item-action" data-product-id="${p.productID}" data-product-name="${p.name}">
            <strong>${p.name}</strong> (${p.productID})<br>
            <small class="text-muted">${p.description || ''}</small>
          </a>
        `).join('');
        
        resultsDiv.style.display = 'block';
        
        // Add click handlers
        resultsDiv.querySelectorAll('.list-group-item-action').forEach(item => {
          item.addEventListener('click', (e) => {
            e.preventDefault();
            selectedProduct = {
              id: item.dataset.productId,
              name: item.dataset.productName
            };
            searchInput.value = item.dataset.productName;
            productSelect.value = item.dataset.productId;
            productSelect.style.display = 'block';
            resultsDiv.style.display = 'none';
          });
        });
      });
      
      // Hide results when clicking outside
      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !resultsDiv.contains(e.target)) {
          resultsDiv.style.display = 'none';
        }
      });
      
      return () => selectedProduct;
    }
    
    // Serial number input handler (barcode scanner support)
    function setupSerialNumberInput() {
      const serialInput = document.getElementById('serialNumberInput');
      
      // Auto-submit on Enter (barcode scanner typically sends Enter)
      serialInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          // Don't auto-submit, just focus next field
          document.getElementById('serialWarehouse')?.focus();
        }
      });
      
      // Handle barcode scanner (usually sends data quickly)
      let lastValue = '';
      serialInput.addEventListener('input', (e) => {
        const currentValue = e.target.value;
        // If value changed very quickly, likely from scanner
        if (currentValue.length > lastValue.length + 5) {
          setTimeout(() => {
            document.getElementById('serialWarehouse')?.focus();
          }, 100);
        }
        lastValue = currentValue;
      });
    }
    
    // Serial numbers input handler for movement
    function setupSerialNumbersInput() {
      const serialInput = document.getElementById('serialNumbersInput');
      const qtyInput = document.getElementById('stockQty');
      const previewDiv = document.getElementById('serialPreview');
      
      serialInput.addEventListener('input', (e) => {
        const input = e.target.value.trim();
        if (!input) {
          qtyInput.value = '';
          previewDiv.style.display = 'none';
          return;
        }
        
        // Parse serial numbers (comma-separated or line-separated)
        const serials = input.split(/[,\n]/).map(s => s.trim()).filter(s => s);
        
        // Validate and get product info
        const serialInfo = [];
        const errors = [];
        
        serials.forEach(serial => {
          const mapping = SerialTracker.getProductBySerial(serial);
          if (mapping) {
            serialInfo.push({
              serial: serial,
              productID: mapping.productID,
              productName: mapping.productName,
              warehouse: mapping.warehouse
            });
          } else {
            errors.push(serial);
          }
        });
        
        // Update quantity
        qtyInput.value = serialInfo.length;
        
        // Show preview
        if (serialInfo.length > 0) {
          const grouped = {};
          serialInfo.forEach(info => {
            const key = info.productID;
            if (!grouped[key]) {
              grouped[key] = {
                productName: info.productName,
                count: 0,
                serials: []
              };
            }
            grouped[key].count++;
            grouped[key].serials.push(info.serial);
          });
          
          previewDiv.innerHTML = `
            <strong>Found ${serialInfo.length} serial number(s):</strong><br>
            ${Object.keys(grouped).map(key => `
              ${grouped[key].productName}: ${grouped[key].count} item(s)
            `).join('<br>')}
            ${errors.length > 0 ? `<br><small class="text-danger">Unknown serials: ${errors.join(', ')}</small>` : ''}
          `;
          previewDiv.style.display = 'block';
          previewDiv.className = errors.length > 0 ? 'alert alert-warning' : 'alert alert-info';
        } else if (errors.length > 0) {
          previewDiv.innerHTML = `<small class="text-danger">No mapped serial numbers found. Please map them first.</small>`;
          previewDiv.style.display = 'block';
          previewDiv.className = 'alert alert-danger';
        }
      });
    }
    
    function applyMovementFilters() {
      const dateFrom = document.getElementById('filterMovementDate').value;
      const dateTo = document.getElementById('filterDateTo').value;
      const warehouse = document.getElementById('filterMovementWarehouse').value;
      const type = document.getElementById('filterMovementType').value;
      
      filteredMovements = allMovements.filter(movement => {
        const movementDate = movement.date || '';
        const dateMatch = (!dateFrom || movementDate >= dateFrom) && (!dateTo || movementDate <= dateTo);
        const warehouseMatch = !warehouse || (movement.warehouse || '').toUpperCase() === warehouse.toUpperCase();
        const typeMatch = !type || (movement.type || '').toUpperCase() === type.toUpperCase();
        
        return dateMatch && warehouseMatch && typeMatch;
      });
      
      filteredMovements.sort((a, b) => {
        const dateA = new Date(a.date || '1970-01-01');
        const dateB = new Date(b.date || '1970-01-01');
        return dateB - dateA;
      });
      
      currentPage = 1;
      renderMovements();
    }
    
    function resetMovementFilters() {
      // Reset to past 7 days default
      const today = new Date();
      const sevenDaysAgo = new Date(today);
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      
      document.getElementById('filterMovementDate').value = sevenDaysAgo.toISOString().split('T')[0];
      document.getElementById('filterDateTo').value = today.toISOString().split('T')[0];
      document.getElementById('filterMovementWarehouse').value = '';
      document.getElementById('filterMovementType').value = '';
      
      // Apply default filter
      applyMovementFilters();
    }
    
    function renderMovements() {
      const tbody = document.getElementById('movementsTable');
      if (!tbody) return;
      
      const startIdx = (currentPage - 1) * itemsPerPage;
      const endIdx = startIdx + itemsPerPage;
      const pageMovements = filteredMovements.slice(startIdx, endIdx);
      
        if (pageMovements.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="text-center">No movements found</td></tr>';
        document.getElementById('movementPageInfo').textContent = '';
        renderPagination(0);
        return;
      }
      
      tbody.innerHTML = pageMovements.map(movement => {
        const typeClass = movement.type === 'In' ? 'status-fulfilled' : 'status-processing';
        const serialNumbers = movement.serialnumbers || movement.serialNumbers || '';
        const serialDisplay = serialNumbers ? 
          `<small>${serialNumbers.split(',').slice(0, 3).join(', ')}${serialNumbers.split(',').length > 3 ? '...' : ''}</small>` : 
          '<small class="text-muted">-</small>';
        return `
          <tr>
            <td>${movement.date || ''}</td>
            <td>${movement.warehouse || ''}</td>
            <td>${movement.productid || movement.productID || ''}</td>
            <td><span class="badge ${typeClass}">${movement.type || ''}</span></td>
            <td>${movement.qty || ''}</td>
            <td>${serialDisplay}</td>
            <td>${movement.notes || ''}</td>
            <td>${movement.user || ''}</td>
          </tr>
        `;
      }).join('');
      
      // Update page info
      const totalPages = Math.ceil(filteredMovements.length / itemsPerPage);
      document.getElementById('movementPageInfo').textContent = 
        `Page ${currentPage} of ${totalPages} (${filteredMovements.length} total)`;
      
      renderPagination(totalPages);
    }
    
    function renderPagination(totalPages) {
      const pagination = document.getElementById('movementPagination');
      if (!pagination) return;
      
      if (totalPages <= 1) {
        pagination.innerHTML = '';
        return;
      }
      
      let html = '';
      
      // Previous button
      html += `<li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
        <a class="page-link" href="#" onclick="changePage(${currentPage - 1}); return false;">Previous</a>
      </li>`;
      
      // Page numbers
      for (let i = 1; i <= totalPages; i++) {
        if (i === 1 || i === totalPages || (i >= currentPage - 1 && i <= currentPage + 1)) {
          html += `<li class="page-item ${i === currentPage ? 'active' : ''}">
            <a class="page-link" href="#" onclick="changePage(${i}); return false;">${i}</a>
          </li>`;
        } else if (i === currentPage - 2 || i === currentPage + 2) {
          html += `<li class="page-item disabled"><span class="page-link">...</span></li>`;
        }
      }
      
      // Next button
      html += `<li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
        <a class="page-link" href="#" onclick="changePage(${currentPage + 1}); return false;">Next</a>
      </li>`;
      
      pagination.innerHTML = html;
    }
    
    function changePage(page) {
      const totalPages = Math.ceil(filteredMovements.length / itemsPerPage);
      if (page < 1 || page > totalPages) return;
      currentPage = page;
      renderMovements();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    async function exportMovements() {
      exportToCSV(filteredMovements, `stock_movements_${new Date().toISOString().split('T')[0]}.csv`);
      showToast('Movements exported to CSV', 'success');
    }
    
    // Serial mapping form submission
    document.getElementById('serialMappingForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const serialNumber = document.getElementById('serialNumberInput').value.trim();
      const productID = document.getElementById('serialProduct').value;
      const warehouse = document.getElementById('serialWarehouse').value;
      
      if (!serialNumber || !productID || !warehouse) {
        showToast('Please fill all required fields', 'danger');
        return;
      }
      
      const product = allProducts.find(p => p.productID === productID);
      if (!product) {
        showToast('Product not found', 'danger');
        return;
      }
      
      const result = await SerialTracker.mapSerialNumber(serialNumber, productID, product.name, warehouse);
      
      if (result.success) {
        // Log audit event
        if (typeof logAuditEvent === 'function') {
          await logAuditEvent({
            action: 'CREATE',
            entity: 'SerialNumber',
            entityID: serialNumber,
            newValue: { productID, productName: product.name, warehouse },
            details: `Serial number ${serialNumber} mapped to product ${product.name} (${productID}) at ${warehouse}`
          });
        }
        
        showToast(`Serial number ${serialNumber} mapped to ${product.name}`, 'success');
        document.getElementById('serialMappingForm').reset();
        document.getElementById('serialNumberInput').focus();
      } else {
        showToast(result.error, 'danger');
      }
    });
    
    // Stock form submission (using serial numbers)
    document.getElementById('stockForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const serialNumbersInput = document.getElementById('serialNumbersInput').value.trim();
      if (!serialNumbersInput) {
        showToast('Please scan or enter serial numbers', 'danger');
        return;
      }
      
      // Parse serial numbers
      const serials = serialNumbersInput.split(/[,\n]/).map(s => s.trim()).filter(s => s);
      
      // Get product info from serial numbers
      const serialInfo = [];
      const errors = [];
      
      serials.forEach(serial => {
        const mapping = SerialTracker.getProductBySerial(serial);
        if (mapping) {
          serialInfo.push(mapping);
        } else {
          errors.push(serial);
        }
      });
      
      if (errors.length > 0) {
        showToast(`Unmapped serial numbers: ${errors.join(', ')}. Please map them first.`, 'danger');
        return;
      }
      
      if (serialInfo.length === 0) {
        showToast('No valid serial numbers found', 'danger');
        return;
      }
      
      // Group by product and warehouse
      const grouped = {};
      serialInfo.forEach(info => {
        const key = `${info.productID}_${info.warehouse}`;
        if (!grouped[key]) {
          grouped[key] = {
            productID: info.productID,
            warehouse: info.warehouse,
            serials: []
          };
        }
        grouped[key].serials.push(info);
      });
      
      // Create movements for each product/warehouse combination
      const type = document.getElementById('stockType').value;
      const notes = document.getElementById('stockNotes').value || '';
      const user = Auth.getCurrentUser()?.name || 'System';
      
      try {
        for (const key in grouped) {
          const group = grouped[key];
          const movement = {
            warehouse: group.warehouse,
            productID: group.productID,
            type: type,
            qty: group.serials.length,
            serialNumbers: group.serials.map(s => s.serial).filter(s => s).join(','),
            notes: notes || `Serial numbers: ${group.serials.length} items`,
            user: user
          };
          
          const result = await logMovement(movement);
          
          // Update serial status (serial numbers are already in the movement, no need to look them up)
          // Note: Serial status is managed through the movement logging
          // If specific status updates are needed, they should be handled separately
        }
        
        showToast('Stock movement recorded successfully', 'success');
        document.getElementById('stockForm').reset();
        document.getElementById('serialPreview').style.display = 'none';
        await loadStock();
      } catch (error) {
        console.error('Stock movement error:', error);
        showToast('Error recording movement', 'danger');
      }
    });
    
    // Combo breakdown form submission
    document.getElementById('comboBreakdownForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const comboSerial = document.getElementById('comboSerial').value.trim();
      const comboMapping = SerialTracker.getProductBySerial(comboSerial);
      
      if (!comboMapping) {
        showToast('Combo serial number not found', 'danger');
        return;
      }
      
      // Get individual products
      const productRows = document.querySelectorAll('#individualProductsList > .row');
      const individualProducts = [];
      
      productRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        const productInput = inputs[0].value.trim();
        const qty = parseInt(inputs[1].value);
        const serialsInput = inputs[2].value.trim();
        
        if (productInput && qty > 0 && serialsInput) {
          const product = allProducts.find(p => 
            p.productID.toLowerCase() === productInput.toLowerCase() || 
            p.name.toLowerCase() === productInput.toLowerCase()
          );
          
          if (product) {
            const serials = serialsInput.split(',').map(s => s.trim()).filter(s => s);
            if (serials.length === qty) {
              individualProducts.push({
                productID: product.productID,
                productName: product.name,
                quantity: qty,
                serialNumbers: serials
              });
            }
          }
        }
      });
      
      if (individualProducts.length === 0) {
        showToast('Please add at least one individual product', 'danger');
        return;
      }
      
      const result = SerialTracker.breakdownCombo(comboMapping.productID, comboSerial, individualProducts);
      
      if (result.success) {
        document.getElementById('breakdownRef').value = result.referenceNumber;
        showToast(`Combo broken down successfully. Reference: ${result.referenceNumber}`, 'success');
        
        // Optionally log the breakdown as stock movement
        setTimeout(() => {
          document.getElementById('comboBreakdownForm').reset();
          document.getElementById('breakdownRef').value = '';
          document.getElementById('individualProductsList').innerHTML = '<div class="row g-2 mb-2"><div class="col-md-4"><input type="text" class="form-control" placeholder="Product ID or Name" required></div><div class="col-md-2"><input type="number" class="form-control" placeholder="Qty" min="1" required></div><div class="col-md-5"><input type="text" class="form-control" placeholder="Serial Numbers (comma-separated)" required></div><div class="col-md-1"><button type="button" class="btn btn-danger" onclick="removeProductRow(this)">-</button></div></div>';
        }, 3000);
      } else {
        showToast('Failed to break down combo', 'danger');
      }
    });
    
    // Helper functions for combo breakdown
    function addProductRow() {
      const list = document.getElementById('individualProductsList');
      const row = document.createElement('div');
      row.className = 'row g-2 mb-2';
      row.innerHTML = `
        <div class="col-md-4">
          <input type="text" class="form-control" placeholder="Product ID or Name" required>
        </div>
        <div class="col-md-2">
          <input type="number" class="form-control" placeholder="Qty" min="1" required>
        </div>
        <div class="col-md-5">
          <input type="text" class="form-control" placeholder="Serial Numbers (comma-separated)" required>
        </div>
        <div class="col-md-1">
          <button type="button" class="btn btn-danger" onclick="removeProductRow(this)">-</button>
        </div>
      `;
      list.appendChild(row);
    }
    
    function removeProductRow(button) {
      button.closest('.row').remove();
    }
    
    window.addProductRow = addProductRow;
    window.removeProductRow = removeProductRow;
    
    // Search product on everse.in from stock management
    async function searchProductOnEverse() {
      const searchTerm = document.getElementById('productSearch').value.trim();
      if (!searchTerm) {
        const term = prompt('Enter product name to search on everse.in:');
        if (!term) return;
        document.getElementById('productSearch').value = term;
        await searchProductOnEverse();
        return;
      }
      
      showToast('Searching everse.in...', 'info');
      
      try {
        const result = await ProductScraper.searchProduct(searchTerm);
        
        if (result.success && result.products && result.products.length > 0) {
          // Show results in product search results div
          const resultsDiv = document.getElementById('productSearchResults');
          resultsDiv.innerHTML = `
            <div class="alert alert-info mb-2">
              <strong>Found on everse.in:</strong>
            </div>
            ${result.products.slice(0, 5).map((product, idx) => `
              <div class="list-group-item">
                <div class="d-flex justify-content-between align-items-start">
                  <div>
                    <strong>${product.name}</strong><br>
                    <small>${product.description ? product.description.substring(0, 80) + '...' : ''}</small>
                    ${product.price > 0 ? `<br><small>Price: ‚Çπ${product.price}</small>` : ''}
                  </div>
                  <button class="btn btn-sm btn-primary" onclick="useEverseProductForMapping(${idx})">Use</button>
                </div>
              </div>
            `).join('')}
          `;
          resultsDiv.style.display = 'block';
          window.everseSearchResults = result.products;
        } else {
          showToast('No products found on everse.in', 'warning');
        }
      } catch (error) {
        console.error('Everse search error:', error);
        showToast('Search failed. Using local products only.', 'warning');
      }
    }
    
    // Use everse product for serial mapping
    function useEverseProductForMapping(index) {
      const products = window.everseSearchResults;
      if (!products || !products[index]) return;
      
      const product = products[index];
      
      // Check if product exists in inventory
      let existingProduct = allProducts.find(p => 
        p.name.toLowerCase() === product.name.toLowerCase()
      );
      
      if (existingProduct) {
        // Product exists - select it
        document.getElementById('productSearch').value = existingProduct.name;
        document.getElementById('serialProduct').value = existingProduct.productID;
        document.getElementById('serialProduct').style.display = 'block';
        document.getElementById('productSearchResults').style.display = 'none';
        showToast('Product selected from inventory', 'success');
      } else {
        // Product doesn't exist - offer to add it
        if (confirm(`Product "${product.name}" not found in inventory. Add it now?`)) {
          // Auto-add product to inventory first
          const newProductID = product.name.toUpperCase().replace(/[^A-Z0-9]/g, '').substring(0, 10) + '-' + Date.now().toString().slice(-4);
          const newProduct = {
            productID: newProductID,
            name: product.name,
            description: product.description || '',
            unitCost: product.price > 0 ? Math.round(product.price * 0.7) : 0,
            reorderLevel: 10,
            stock: { Bangalore: 0, Kolkata: 0, Chennai: 0, Mumbai: 0 }
          };
          
          // Add to inventory via API
          AutoProduct.addProductToInventory(newProduct).then(result => {
            if (result.success) {
              allProducts.push(newProduct);
              document.getElementById('productSearch').value = newProduct.name;
              document.getElementById('serialProduct').value = newProduct.productID;
              document.getElementById('serialProduct').style.display = 'block';
              document.getElementById('productSearchResults').style.display = 'none';
              showToast('Product added and selected!', 'success');
            }
          });
        }
      }
    }
    
    window.searchProductOnEverse = searchProductOnEverse;
    window.useEverseProductForMapping = useEverseProductForMapping;
    
    // Initialize
    document.addEventListener('DOMContentLoaded', loadStock);
  </script>
</body>
</html>

